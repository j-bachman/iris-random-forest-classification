# -*- coding: utf-8 -*-
"""James - End of Week Assessment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IUYYuZ3iq-XVNk30UBJjwXKcLlneReHL
"""

!pip install ucimlrepo

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from ucimlrepo import fetch_ucirepo
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import confusion_matrix
iris = fetch_ucirepo(id=53)
df = pd.DataFrame(iris.data.features)
df['class'] = iris.data.targets

df

"""<h1>Complete the following:</h1>
<ol>
  <li>Produce a heatmap that shows the correlations within the data.</li>
    <ul>
      <li>The code for doing this is provided in <strong>Day 1 Notebook</strong>.</li>
      <li>You can find documentation for heatmapping in seaborn <a href = "https://seaborn.pydata.org/generated/seaborn.heatmap.html">here</a></li>
      <li>Hint: A heatmap cannot process text data. You need to either select for just numeric data or transform your text data into numeric data.</li>
    </ul>
  <li>Produce a boxplot that shows the ranges for each of the different numeric columns.</li>
    <ul>
      <li>The documentation for how to create a boxplot using matplotlib.pyplot is <a href = "https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.boxplot.html">here</a>.
    </ul>
  <li>Split your data into training and testing data, making sure that you shuffle it.</li>
    <ul>
      <li>We saw how to do this in <strong>Day 3 Notebook</strong>.</li>
      <li>The documentation for train_test_split is <a href = "https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html">here</a>.</li>
    </ul>
  <li>Create a grid of different hyperparameter values for n_estimators, max_depth, and random_state for a Random Forest classifier.</li>
    <ul>
      <li>This is the most difficult step! We saw how to do this in <strong>Day 3 Notebook</strong>.</li>
      <li>The documentation for grid search can be found <a href = "https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html">here</a>.</li>
      <li>The documentation for Random Forest Classifier can be found <a href = "https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html">here</a> with a list of <strong>potential hyperparameters</strong> to use.</li>
    </ul>
  <li>Use the best hyperparameters to train a Random Forest classifier.</li>
    <ul>
      <li>We saw how to do this in <strong>Day 3 Notebook</strong>.</li>
      <li>You can determine what the best parameters are using <strong>.best_params_</strong> after performing a grid search.</li>
    </ul>
  <li>Use a confusion matrix to calculate the accuracy of your predictions.</li>
    <ul>
      <li>We saw how to do this in <strong>Day 3 Notebook</strong>.</li>
      <li>The documentation for confusion matrices can be found <a href = "https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html">here</a>.</li>
    </ul>
</ol>
<br /><br />
Try your best to tackle these problems step by step. Ask for help. Every package and function you need is imported and every line of code necessary to complete this project can be found within the lecture notebooks. Take a deep breath -- you all have the skills to do this!
"""

numeric = ["sepal length", "sepal width", "petal length", "petal width"]

dfNumsOnly = df.loc[:,numeric]

corr_mat = dfNumsOnly.corr()
sns.heatmap(corr_mat, cmap="Blues", annot=True)

plt.boxplot(dfNumsOnly)

x_train, x_test, y_train, y_test = train_test_split(df.loc[:,numeric], df["class"], test_size = 0.2)

param_grid = {'n_estimators': [100, 200, 300], 'max_depth': [None, 1], 'max_features': [None, 1]}
rf = RandomForestClassifier()
grid_search = GridSearchCV(rf, param_grid)

grid_search.fit(x_train, y_train)

grid_search.best_params_

rf = RandomForestClassifier(max_depth = None, max_features = None, n_estimators = 100)
rf.fit(x_train, y_train)

pred_y_train = rf.predict(x_train)
pred_y_test = rf.predict(x_test)

confusion_matrix(y_train, pred_y_train)

confusion_matrix(y_test, pred_y_test)